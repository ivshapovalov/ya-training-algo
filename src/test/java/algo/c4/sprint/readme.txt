A: способ 1: зафиксируем два указателя: один по квадратам, другой по кубам, будем их двигать и увеличивать счётчик
текущего количества чисел в последовательности (если в какой-то момент нашли число, которое является и квадратом, и
кубом, то подвинули оба указателя, иначе меньший), делаем так до тех пор, пока не найдём нужное по счёту способ 2:
возможно, предыдущий не зайдёт на питоне (~10**7 операций всё-таки), поэтому время оптимайзов. пусть мы нашли некоторое
число x, которое является квадратом/кубом/сразу двумя. Как понять, какое оно по счёту? давайте r2 = квадратный корень,
r3 = кубический. Округлим оба корня вниз до целого, тогда у нас получилось число квадратов, меньших x, а ещё число
кубов, меньших x. Если из  (r2 + r3) вычесть r6 = корень 6 степени из x, то получим количество чисел в
последовательности, которые меньше x (с днём дня принципа включений-исключений). Время бинпоиска! Я не пробовал, но
должно работать

B: посчитаем хэши на префиксах строки и на префиксах перевёрнутой строки. Тогда ans[i] = наибольшее k такое, что хэш
префикса первой строки равен хэшу подстроки перевёрнутой. Да. Опять бинпоиск.

C: давайте предположим, что мы хотим провезти x кружек. Как проверить? Квадейкстрой по графу (игнорим рёбра, которые не
выдержат столько кружек). Если добрались до последней вершины не более чем за 24 * 60 = 1440 секунд, то ура, иначе не
ура. Как перебирать x? Вы не поверите, но снова бинпоиском.

D: ура, задача не на бинпоиск! (или я просто его ещё не придумал, но я и не пытался. как говорил один мой друг (а теперь
я так тоже говорю), 'я однажды задумался и больше не думал') спойлер: эту штуку зовут meet-in-the-middle. Давайте будем
думать, что у нас M уникальных кирпичей. По ним можно сделать полный перебор и посчитать длины для всех возможных сумм.
Сохраним их в хэшмапу<суммарная длина выбранных кирпичей, набор кирпичей>, то есть из инта в массив. При этом массив
должен быть минимальной длины. Что дальше? А давайте переберём все элементы из хэшмапы. Пусть сейчас рассматриваем
какую-то пару <длина, множество кирпичей>. Тогда если мы можем взять из оставшихся M кирпичей какое-то подмножество так,
что сумма длин = N, то вот потенциальный ответ, иначе не можем никак. Поэтому просто проверяем наличие в хэшмапе
элемента по ключу N - текущая длина, если нашли, то фиксируем. Из всех кандидатов надо выбрать тот, где количество
элементов в двух массивах в сумме минимальна. Ну и не забыть проверить, что 2 * сумма всех кирпичей >= N, а то если это
не выполняется, то ответ -1